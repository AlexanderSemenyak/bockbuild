diff --git a/gdk/gdkdisplay.c b/gdk/gdkdisplay.c
index f7b43cf..75f3c3f 100644
--- a/gdk/gdkdisplay.c
+++ b/gdk/gdkdisplay.c
@@ -805,6 +805,7 @@ _gdk_display_add_pointer_grab (GdkDisplay *display,
   info->event_mask = event_mask;
   info->time = time;
   info->implicit = implicit;
+  info->resizing = FALSE;
 
   /* Find the first grab that has a larger start time (if any) and insert
    * before that. I.E we insert after already existing grabs with same
diff --git a/gdk/gdkinternals.h b/gdk/gdkinternals.h
index e861a4e..14a1be1 100644
--- a/gdk/gdkinternals.h
+++ b/gdk/gdkinternals.h
@@ -185,6 +185,8 @@ typedef struct
 
   gboolean activated;
   gboolean implicit_ungrab;
+  gboolean resizing;
+
 } GdkPointerGrabInfo;
 
 typedef struct _GdkInputWindow GdkInputWindow;
diff --git a/gdk/gdkwindow.c b/gdk/gdkwindow.c
index f058570..5365a85 100644
--- a/gdk/gdkwindow.c
+++ b/gdk/gdkwindow.c
@@ -10742,6 +10742,8 @@ proxy_button_event (GdkEvent *source_event,
 	  w = parent;
 	}
       pointer_window = (GdkWindow *)w;
+      if (!pointer_window)
+	  pointer_window = toplevel_window;
 
       _gdk_display_add_pointer_grab  (display,
 				      pointer_window,
diff --git a/gdk/quartz/gdkevents-quartz.c b/gdk/quartz/gdkevents-quartz.c
index 1334d83..1eb367e 100644
--- a/gdk/quartz/gdkevents-quartz.c
+++ b/gdk/quartz/gdkevents-quartz.c
@@ -559,6 +559,7 @@ find_window_for_ns_event (NSEvent *nsevent,
   NSPoint point;
   NSPoint screen_point;
   NSEventType event_type;
+  const gint GDK_LION_RESIZE = 5;
 
   view = (GdkQuartzView *)[[nsevent window] contentView];
 
@@ -606,6 +607,8 @@ find_window_for_ns_event (NSEvent *nsevent,
         grab = _gdk_display_get_last_pointer_grab (display);
 	if (WINDOW_IS_TOPLEVEL (toplevel) && grab)
 	  {
+	    if (grab->resizing)
+	      return NULL;
             /* Implicit grabs do not go through XGrabPointer and thus the
              * event mask should not be checked.
              */
@@ -623,7 +626,11 @@ find_window_for_ns_event (NSEvent *nsevent,
                 GdkWindow *toplevel_under_pointer;
                 gint x_tmp, y_tmp;
 
-                toplevel_under_pointer = find_toplevel_under_pointer (display,
+
+		if (grab->resizing)
+		    return NULL;
+
+               toplevel_under_pointer = find_toplevel_under_pointer (display,
                                                                       screen_point,
                                                                       &x_tmp, &y_tmp);
                 if (toplevel_under_pointer)
@@ -642,6 +649,9 @@ find_window_for_ns_event (NSEvent *nsevent,
                 GdkWindowObject *grab_private;
                 NSWindow *grab_nswindow;
 
+		if (!grab->window)
+		  return NULL;
+
 		grab_toplevel = gdk_window_get_effective_toplevel (grab->window);
                 grab_private = (GdkWindowObject *)grab_toplevel;
 
@@ -652,7 +662,21 @@ find_window_for_ns_event (NSEvent *nsevent,
                 *x = point.x;
                 *y = grab_private->height - point.y;
 
-		return grab_toplevel;
+		/* If we're on Lion and within 5 pixels of an edge, then
+		 * assume that the user wants to resize, and return NULL to
+		 * let Quartz get on with it. We check the selector
+		 * isRestorable to see if we're on 10.7.
+		 */
+		if (event_type != NSLeftMouseUp &&
+		    ([grab_nswindow respondsToSelector:@selector(isRestorable)]) &&
+		    (*x < GDK_LION_RESIZE ||
+                     *x > grab_private->width - GDK_LION_RESIZE ||
+                     *y > grab_private->height - GDK_LION_RESIZE))
+		{
+		    grab->resizing = TRUE;
+		    return NULL;
+		}
+ 		return grab_toplevel;
 	      }
 
 	    return NULL;
@@ -683,6 +707,7 @@ find_window_for_ns_event (NSEvent *nsevent,
               {
                 GdkWindowObject *toplevel_private;
                 GdkWindowImplQuartz *toplevel_impl;
+                gboolean lion;
 
                 toplevel = toplevel_under_pointer;
 
@@ -712,6 +737,20 @@ find_window_for_ns_event (NSEvent *nsevent,
                         return NULL;
                       }
                   }
+		/* If we're on Lion and within 5 pixels of an edge,
+		 * then assume that the user wants to resize, and
+		 * return NULL to let Quartz get on with it. We check
+		 * the selector isRestorable to see if we're on 10.7.
+		 * This extra check is in case the user starts
+		 * dragging before GDK recognizes the grab.
+		 */
+		lion = [toplevel_impl->toplevel respondsToSelector:@selector(isRestorable)];
+		if (lion && (*x < GDK_LION_RESIZE ||
+                             *x > toplevel_private->width - GDK_LION_RESIZE ||
+                             *y > toplevel_private->height - GDK_LION_RESIZE))
+		  {
+                    return NULL;
+                  }
 
                 *x = x_tmp;
                 *y = y_tmp;
