diff --git a/gdk/gdkwindow.c b/gdk/gdkwindow.c
index f058570..5365a85 100644
--- a/gdk/gdkwindow.c
+++ b/gdk/gdkwindow.c
@@ -10742,6 +10742,8 @@ proxy_button_event (GdkEvent *source_event,
 	  w = parent;
 	}
       pointer_window = (GdkWindow *)w;
+      if (!pointer_window)
+	  pointer_window = toplevel_window;
 
       _gdk_display_add_pointer_grab  (display,
 				      pointer_window,
diff --git a/gdk/quartz/gdkevents-quartz.c b/gdk/quartz/gdkevents-quartz.c
index 1334d83..d6ee6d5 100644
--- a/gdk/quartz/gdkevents-quartz.c
+++ b/gdk/quartz/gdkevents-quartz.c
@@ -33,6 +33,8 @@
 #include "gdkkeysyms.h"
 #include "gdkprivate-quartz.h"
 
+#define GDK_LION_RESIZE 5
+
 #define GRIP_WIDTH 15
 #define GRIP_HEIGHT 15
 
@@ -642,7 +644,10 @@ find_window_for_ns_event (NSEvent *nsevent,
                 GdkWindowObject *grab_private;
                 NSWindow *grab_nswindow;
 
-		grab_toplevel = gdk_window_get_effective_toplevel (grab->window);
+                if (!grab->window)
+                  return NULL;
+
+                grab_toplevel = gdk_window_get_effective_toplevel (grab->window);
                 grab_private = (GdkWindowObject *)grab_toplevel;
 
                 grab_nswindow = ((GdkWindowImplQuartz *)grab_private->impl)->toplevel;
@@ -652,7 +657,20 @@ find_window_for_ns_event (NSEvent *nsevent,
                 *x = point.x;
                 *y = grab_private->height - point.y;
 
-		return grab_toplevel;
+                /* If we're on Lion and within 5 pixels of an edge, then
+                 * assume that the user wants to resize, and return NULL to
+                 * let Quartz get on with it. We check the selector
+                 * isRestorable to see if we're on 10.7.
+                 */
+                if (([grab_nswindow respondsToSelector:@selector(isRestorable)]) &&
+                    (*x < GDK_LION_RESIZE ||
+                     *x > grab_private->width - GDK_LION_RESIZE ||
+                     *y > grab_private->height - GDK_LION_RESIZE))
+                  {
+                    return NULL;
+                  }
+
+                return grab_toplevel;
 	      }
 
 	    return NULL;
@@ -661,7 +679,10 @@ find_window_for_ns_event (NSEvent *nsevent,
 	  {
 	    /* The non-grabbed case. */
             GdkWindow *toplevel_under_pointer;
+            GdkWindowObject *toplevel_private;
+            GdkWindowImplQuartz *toplevel_impl;
             gint x_tmp, y_tmp;
+            gboolean lion;
 
             /* Ignore all events but mouse moved that might be on the title
              * bar (above the content view). The reason is that otherwise
@@ -678,45 +699,54 @@ find_window_for_ns_event (NSEvent *nsevent,
             toplevel_under_pointer = find_toplevel_under_pointer (display,
                                                                   screen_point,
                                                                   &x_tmp, &y_tmp);
-            if (toplevel_under_pointer
-                && WINDOW_IS_TOPLEVEL (toplevel_under_pointer))
-              {
-                GdkWindowObject *toplevel_private;
-                GdkWindowImplQuartz *toplevel_impl;
-
-                toplevel = toplevel_under_pointer;
+            if (toplevel_under_pointer && WINDOW_IS_TOPLEVEL (toplevel_under_pointer))
+	      toplevel = toplevel_under_pointer;
 
-                toplevel_private = (GdkWindowObject *)toplevel;
-                toplevel_impl = (GdkWindowImplQuartz *)toplevel_private->impl;
+            toplevel_private = (GdkWindowObject *)toplevel;
+            toplevel_impl = (GdkWindowImplQuartz *)toplevel_private->impl;
 
-                if ([toplevel_impl->toplevel showsResizeIndicator])
+            if ([toplevel_impl->toplevel showsResizeIndicator])
+              {
+                NSRect frame;
+
+                /* If the resize indicator is visible and the event
+                 * is in the lower right 15x15 corner, we leave these
+                 * events to Cocoa as to be handled as resize events.
+                 * Applications may have widgets in this area.  These
+                 * will most likely be larger than 15x15 and for
+                 * scroll bars there are also other means to move
+                 * the scroll bar.  Since the resize indicator is
+                 * the only way of resizing windows on Mac OS, it
+                 * is too important to not make functional.
+                 */
+                frame = [toplevel_impl->view bounds];
+                if (x_tmp > frame.size.width - GRIP_WIDTH
+                    && x_tmp < frame.size.width
+                    && y_tmp > frame.size.height - GRIP_HEIGHT
+                    && y_tmp < frame.size.height)
                   {
-                    NSRect frame;
-
-                    /* If the resize indicator is visible and the event
-                     * is in the lower right 15x15 corner, we leave these
-                     * events to Cocoa as to be handled as resize events.
-                     * Applications may have widgets in this area.  These
-                     * will most likely be larger than 15x15 and for
-                     * scroll bars there are also other means to move
-                     * the scroll bar.  Since the resize indicator is
-                     * the only way of resizing windows on Mac OS, it
-                     * is too important to not make functional.
-                     */
-                    frame = [toplevel_impl->view bounds];
-                    if (x_tmp > frame.size.width - GRIP_WIDTH
-                        && x_tmp < frame.size.width
-                        && y_tmp > frame.size.height - GRIP_HEIGHT
-                        && y_tmp < frame.size.height)
-                      {
-                        return NULL;
-                      }
+                    return NULL;
                   }
+              }
 
-                *x = x_tmp;
-                *y = y_tmp;
+            /* If we're on Lion and within 5 pixels of an edge,
+             * then assume that the user wants to resize, and
+             * return NULL to let Quartz get on with it. We check
+             * the selector isRestorable to see if we're on 10.7.
+             * This extra check is in case the user starts
+             * dragging before GDK recognizes the grab.
+             */
+            lion = [toplevel_impl->toplevel respondsToSelector:@selector(isRestorable)];
+            if (lion && (*x < GDK_LION_RESIZE ||
+                         *x > toplevel_private->width - GDK_LION_RESIZE ||
+                         *y > toplevel_private->height - GDK_LION_RESIZE))
+              {
+                return NULL;
               }
 
+            *x = x_tmp;
+            *y = y_tmp;
+
             return toplevel;
 	  }
       }
