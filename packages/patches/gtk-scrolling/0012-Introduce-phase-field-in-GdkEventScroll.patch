From 4d1e332ece27860d5bbc5a9979f99a8a9588350a Mon Sep 17 00:00:00 2001
From: Kristian Rietveld <kris@lanedo.com>
Date: Sun, 2 Sep 2012 14:16:45 +0200
Subject: [PATCH 12/22] Introduce phase field in GdkEventScroll

Using the phase field it is possible to distinguish between
events generated while the user is performing a gesture and
momentum events that are generated after the gesture has been
finished.
---
 gdk/gdkevents.c               |    1 +
 gdk/gdkevents.h               |    9 +++++++++
 gdk/gdkwindow.c               |    1 +
 gdk/quartz/gdkevents-quartz.c |   36 +++++++++++++++++++++++++++++++++---
 4 files changed, 44 insertions(+), 3 deletions(-)

diff --git a/gdk/gdkevents.c b/gdk/gdkevents.c
index 0f8bba2..d3d67db 100644
--- a/gdk/gdkevents.c
+++ b/gdk/gdkevents.c
@@ -394,6 +394,7 @@ gdk_event_new (GdkEventType type)
       new_event->scroll.y_root = 0.;
       new_event->scroll.delta_x = 0.;
       new_event->scroll.delta_y = 0.;
+      new_event->scroll.phase = GDK_EVENT_SCROLL_PHASE_NONE;
       break;
     case GDK_ENTER_NOTIFY:
     case GDK_LEAVE_NOTIFY:
diff --git a/gdk/gdkevents.h b/gdk/gdkevents.h
index e0802eb..f888c91 100644
--- a/gdk/gdkevents.h
+++ b/gdk/gdkevents.h
@@ -263,6 +263,14 @@ typedef enum
   GDK_OWNER_CHANGE_CLOSE
 } GdkOwnerChange;
 
+typedef enum
+{
+  GDK_EVENT_SCROLL_PHASE_NONE,
+  GDK_EVENT_SCROLL_PHASE_START,
+  GDK_EVENT_SCROLL_PHASE_ACTIVE,
+  GDK_EVENT_SCROLL_PHASE_END
+} GdkEventScrollPhase;
+
 struct _GdkEventAny
 {
   GdkEventType type;
@@ -340,6 +348,7 @@ struct _GdkEventScroll
   gboolean has_deltas;
   gdouble delta_x;
   gdouble delta_y;
+  GdkEventScrollPhase phase;
 };
 
 struct _GdkEventKey
diff --git a/gdk/gdkwindow.c b/gdk/gdkwindow.c
index 13d4d46..6150472 100644
--- a/gdk/gdkwindow.c
+++ b/gdk/gdkwindow.c
@@ -10797,6 +10797,7 @@ proxy_button_event (GdkEvent *source_event,
       event->scroll.has_deltas = source_event->scroll.has_deltas;
       event->scroll.delta_x = source_event->scroll.delta_x;
       event->scroll.delta_y = source_event->scroll.delta_y;
+      event->scroll.phase = source_event->scroll.phase;
       return TRUE;
 
     default:
diff --git a/gdk/quartz/gdkevents-quartz.c b/gdk/quartz/gdkevents-quartz.c
index b0be780..96d5341 100644
--- a/gdk/quartz/gdkevents-quartz.c
+++ b/gdk/quartz/gdkevents-quartz.c
@@ -61,6 +61,7 @@ static GdkWindow *find_toplevel_under_pointer   (GdkDisplay *display,
 - (BOOL) hasPreciseScrollingDeltas;
 - (CGFloat) scrollingDeltaX;
 - (CGFloat) scrollingDeltaY;
+- (int) phase;
 @end
 
 
@@ -950,6 +951,7 @@ fill_scroll_event (GdkWindow          *window,
                    gboolean            has_deltas,
                    gdouble             delta_x,
                    gdouble             delta_y,
+                   GdkEventScrollPhase phase,
                    GdkScrollDirection  direction)
 {
   GdkWindowObject *private;
@@ -972,6 +974,7 @@ fill_scroll_event (GdkWindow          *window,
   event->scroll.has_deltas = has_deltas;
   event->scroll.delta_x = delta_x;
   event->scroll.delta_y = delta_y;
+  event->scroll.phase = phase;
 }
 
 static void
@@ -1262,6 +1265,28 @@ test_resize (NSEvent *event, GdkWindow *toplevel, gint x, gint y)
   return FALSE;
 }
 
+static GdkEventScrollPhase
+gdk_event_scroll_phase_from_ns_event_phase (NSUInteger phase)
+{
+  switch (phase)
+    {
+      case 0:
+        return GDK_EVENT_SCROLL_PHASE_NONE;
+
+      case 1 << 0:
+        return GDK_EVENT_SCROLL_PHASE_START;
+
+      case 1 << 1:
+      case 1 << 2:
+        return GDK_EVENT_SCROLL_PHASE_ACTIVE;
+
+      case 1 << 3:
+        return GDK_EVENT_SCROLL_PHASE_END;
+    }
+
+  return GDK_EVENT_SCROLL_PHASE_NONE;
+}
+
 static gboolean
 gdk_event_translate (GdkEvent *event,
                      NSEvent  *nsevent)
@@ -1440,6 +1465,7 @@ gdk_event_translate (GdkEvent *event,
 	if (gdk_quartz_osx_version() >= GDK_OSX_LION &&
 	    [(id <PreciseDeltas>) nsevent hasPreciseScrollingDeltas])
 	  {
+            GdkEventScrollPhase phase;
 	    dx = [(id <PreciseDeltas>) nsevent scrollingDeltaX];
 	    dy = [(id <PreciseDeltas>) nsevent scrollingDeltaY];
 
@@ -1458,8 +1484,10 @@ gdk_event_translate (GdkEvent *event,
                   direction = GDK_SCROLL_LEFT;
               }
 
+            phase = gdk_event_scroll_phase_from_ns_event_phase ([(id <PreciseDeltas>) nsevent phase]);
+
             fill_scroll_event (window, event, nsevent, x, y, x_root, y_root,
-                               TRUE, -dx, -dy, direction);
+                               TRUE, -dx, -dy, phase, direction);
 	  }
 	else
 	  {
@@ -1474,7 +1502,8 @@ gdk_event_translate (GdkEvent *event,
                   direction = GDK_SCROLL_UP;
 
                 fill_scroll_event (window, event, nsevent, x, y, x_root, y_root,
-                                   FALSE, 0.0, fabs (dy), direction);
+                                   FALSE, 0.0, fabs (dy), GDK_EVENT_SCROLL_PHASE_NONE,
+                                   direction);
               }
             else if (dx != 0.0)
               {
@@ -1484,7 +1513,8 @@ gdk_event_translate (GdkEvent *event,
                   direction = GDK_SCROLL_LEFT;
 
                 fill_scroll_event (window, event, nsevent, x, y, x_root, y_root,
-                                   FALSE, fabs (dx), 0.0, direction);
+                                   FALSE, fabs (dx), 0.0, GDK_EVENT_SCROLL_PHASE_NONE,
+                                   direction);
               }
           }
       }
-- 
1.7.5.4

