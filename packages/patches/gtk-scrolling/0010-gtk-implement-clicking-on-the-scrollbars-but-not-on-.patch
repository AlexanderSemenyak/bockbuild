From d558954f43fde5cbc06fe9fc7dfcd8d6075016b7 Mon Sep 17 00:00:00 2001
From: Michael Natterer <mitch@gimp.org>
Date: Tue, 17 Jul 2012 16:38:50 +0200
Subject: [PATCH 10/10] gtk: implement clicking on the scrollbars but not on
 the slider

---
 gtk/gtkscrolledwindow.c |   85 ++++++++++++++++++++++++++++++++++++++++++++++-
 1 files changed, 84 insertions(+), 1 deletions(-)

diff --git a/gtk/gtkscrolledwindow.c b/gtk/gtkscrolledwindow.c
index 37818e5..4ee6d2a 100644
--- a/gtk/gtkscrolledwindow.c
+++ b/gtk/gtkscrolledwindow.c
@@ -84,6 +84,10 @@
 #define OVERSHOOT_INVERSE_ACCELERATION 0.003
 #define RELEASE_EVENT_TIMEOUT 1000
 
+/* Overlay scrollbars */
+#define SCROLL_INTERVAL_INITIAL 300
+#define SCROLL_INTERVAL_REPEAT 100
+
 typedef struct {
   gboolean window_placement_set;
   GtkCornerType real_window_placement;
@@ -134,6 +138,7 @@ typedef struct {
   gint           sb_grab_offset_x;
   gint           sb_grab_offset_y;
 
+  gint           sb_scroll_direction;
   guint          sb_scroll_timeout_id;
 } GtkScrolledWindowPrivate;
 
@@ -2662,6 +2667,46 @@ gtk_scrolled_window_captured_button_press_kinetic (GtkWidget *widget,
     return FALSE;
 }
 
+static void
+gtk_scrolled_window_scroll_step (GtkScrolledWindow *scrolled_window)
+{
+  GtkScrolledWindowPrivate *priv = GTK_SCROLLED_WINDOW_GET_PRIVATE (scrolled_window);
+  GtkAdjustment *adj;
+  gdouble value;
+
+  if (priv->sb_grab_vscroll)
+    {
+      adj = gtk_range_get_adjustment (GTK_RANGE (scrolled_window->vscrollbar));
+    }
+  else if (priv->sb_grab_hscroll)
+    {
+      adj = gtk_range_get_adjustment (GTK_RANGE (scrolled_window->hscrollbar));
+    }
+
+  value = adj->value + (priv->sb_scroll_direction * adj->page_size);
+  value = CLAMP (value, adj->lower, adj->upper - adj->page_size);
+
+  gtk_adjustment_set_value (adj, value);
+}
+
+static gboolean
+gtk_scrolled_window_scroll_step_timeout (gpointer data)
+{
+  GtkScrolledWindow *scrolled_window = GTK_SCROLLED_WINDOW (data);
+  GtkScrolledWindowPrivate *priv = GTK_SCROLLED_WINDOW_GET_PRIVATE (scrolled_window);
+
+  gtk_scrolled_window_scroll_step (scrolled_window);
+
+  g_source_remove (priv->sb_scroll_timeout_id);
+
+  priv->sb_scroll_timeout_id =
+    gdk_threads_add_timeout (SCROLL_INTERVAL_REPEAT,
+                             gtk_scrolled_window_scroll_step_timeout,
+                             scrolled_window);
+
+  return FALSE;
+}
+
 static gboolean
 gtk_scrolled_window_captured_button_press_scrollbar (GtkWidget *widget,
                                                      GdkEvent  *event)
@@ -2706,6 +2751,11 @@ gtk_scrolled_window_captured_button_press_scrollbar (GtkWidget *widget,
             {
               priv->sb_drag_slider = FALSE;
               priv->sb_grab_offset_y = bevent->y - vbar_rect.y;
+
+              if (bevent->y < vslider_rect.y)
+                priv->sb_scroll_direction = -1;
+              else
+                priv->sb_scroll_direction = 1;
             }
         }
       else if (priv->sb_grab_hscroll)
@@ -2717,6 +2767,11 @@ gtk_scrolled_window_captured_button_press_scrollbar (GtkWidget *widget,
             {
               priv->sb_drag_slider = TRUE;
               priv->sb_grab_offset_x = bevent->x - hslider_rect.x;
+
+              if (bevent->x < hslider_rect.x)
+                priv->sb_scroll_direction = -1;
+              else
+                priv->sb_scroll_direction = 1;
             }
           else
             {
@@ -2725,6 +2780,17 @@ gtk_scrolled_window_captured_button_press_scrollbar (GtkWidget *widget,
             }
         }
 
+      if ((priv->sb_grab_vscroll || priv->sb_grab_hscroll) &&
+          !priv->sb_drag_slider)
+        {
+          gtk_scrolled_window_scroll_step (scrolled_window);
+
+          priv->sb_scroll_timeout_id =
+            gdk_threads_add_timeout (SCROLL_INTERVAL_INITIAL,
+                                     gtk_scrolled_window_scroll_step_timeout,
+                                     scrolled_window);
+        }
+
       return TRUE;
     }
 
@@ -2742,9 +2808,15 @@ gtk_scrolled_window_captured_button_release_scrollbar (GtkWidget *widget,
   if (bevent->button != 1)
     return FALSE;
 
-  gtk_grab_add (widget);
+  gtk_grab_remove (widget);
   priv->sb_pointer_grabbed = FALSE;
 
+  if (priv->sb_scroll_timeout_id)
+    {
+      g_source_remove (priv->sb_scroll_timeout_id);
+      priv->sb_scroll_timeout_id = 0;
+    }
+
   return TRUE;
 }
 
@@ -3218,6 +3290,17 @@ gtk_scrolled_window_grab_notify (GtkWidget *widget,
 
       priv->last_button_event_valid = FALSE;
     }
+
+  if (priv->sb_pointer_grabbed && !was_grabbed)
+    {
+      priv->sb_pointer_grabbed = FALSE;
+
+      if (priv->sb_scroll_timeout_id)
+        {
+          g_source_remove (priv->sb_scroll_timeout_id);
+          priv->sb_scroll_timeout_id = 0;
+        }
+    }
 }
 
 static void
-- 
1.7.5.4

