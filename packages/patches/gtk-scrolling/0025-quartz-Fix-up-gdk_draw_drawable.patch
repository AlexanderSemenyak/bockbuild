From be949d42e239afa040315b1773de656d67f8c61e Mon Sep 17 00:00:00 2001
From: Kristian Rietveld <kris@lanedo.com>
Date: Sat, 27 Oct 2012 17:11:59 +0200
Subject: [PATCH 2/2] quartz: Fix up gdk_draw_drawable

---
 gdk/quartz/gdkdrawable-quartz.c |   76 ++++++++++++++++++++++++++++++++++-----
 1 files changed, 67 insertions(+), 9 deletions(-)

diff --git a/gdk/quartz/gdkdrawable-quartz.c b/gdk/quartz/gdkdrawable-quartz.c
index 1bbf7c9..db72cf5 100644
--- a/gdk/quartz/gdkdrawable-quartz.c
+++ b/gdk/quartz/gdkdrawable-quartz.c
@@ -361,15 +361,73 @@ gdk_quartz_draw_drawable (GdkDrawable *drawable,
         {
           NSRect rect = NSMakeRect (xsrc, ysrc, width, height);
           NSSize offset = NSMakeSize (xdest - xsrc, ydest - ysrc);
+          GdkRectangle tmp_rect;
+          GdkRegion *orig_region, *offset_region;
+          GdkWindow *window = GDK_DRAWABLE_IMPL_QUARTZ (drawable)->wrapper;
+
+          /* Origin region */
+          tmp_rect.x = xsrc;
+          tmp_rect.y = ysrc;
+          tmp_rect.width = width;
+          tmp_rect.height = height;
+          orig_region = gdk_region_rectangle (&tmp_rect);
+
+          /* Destination region (or the offset region) */
+          offset_region = gdk_region_copy (orig_region);
+          gdk_region_offset (offset_region, offset.width, offset.height);
+
+          if (window_impl->in_paint_rect_count == 0)
+            {
+              GdkRegion *bottom_border_region;
+
+              /* If we are not in drawRect:, we can use scrollRect:.
+               * We apply scrollRect on the rectangle to be moved and
+               * subtract this area from the rectangle that needs display.
+               *
+               * Note: any area in this moved region that already needed
+               * display will be handled by GDK (queue translation).
+               *
+               * Queuing the redraw below is important, otherwise the
+               * results from scrollRect will not take effect!
+               */
+              [window_impl->view scrollRect:rect by:offset];
+
+              gdk_region_subtract (orig_region, offset_region);
+
+              /* If the moved area intersects the bottom border of the window
+               * (4 pixels), we have to submit this for redisplay. The
+               * window border has rounded rectangles, so we have to fill
+               * the contents that were lost by drawing the rounded corners.
+               */
+              tmp_rect.x = 0;
+              tmp_rect.y = gdk_window_get_height (window) - 4;
+              tmp_rect.width = gdk_window_get_width (window);
+              tmp_rect.height = 4;
+
+              bottom_border_region = gdk_region_rectangle (&tmp_rect);
+              gdk_region_intersect (bottom_border_region,
+                                    orig_region);
+
+              gdk_region_offset (bottom_border_region,
+                                 offset.width, offset.height);
+
+              gdk_region_union (orig_region, bottom_border_region);
+
+              gdk_region_destroy (bottom_border_region);
+            }
+          else
+            {
+              /* If we cannot handle things with a scroll, we must redisplay
+               * the union of the source area and the destination area.
+               */
+              gdk_region_union (orig_region, offset_region);
+            }
 
-          [window_impl->view scrollRect:rect by:offset];
+          _gdk_quartz_window_set_needs_display_in_region (window,
+                                                          orig_region);
 
-          /* The scrollRect only "takes effect" on the next redraw, we must
-           * set that the offset rectangle needs display.
-           */
-          rect.origin.x += offset.width;
-          rect.origin.y += offset.height;
-          [window_impl->view setNeedsDisplayInRect:rect];
+          gdk_region_destroy (orig_region);
+          gdk_region_destroy (offset_region);
         }
       else
         g_warning ("Drawing with window source != dest is not supported");
-- 
1.7.4.4

